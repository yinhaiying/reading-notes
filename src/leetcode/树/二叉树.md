# 二叉树

## 236. 二叉树的最近公共祖先


### 分析
要找到二叉树的最近公共祖先，首先我们要知道都有哪几种情况：
1. 根结点就是其中的一个结点。
![二叉树的最近公共祖先](./imgs/二叉树的最近公共祖先_根结点.jpg)
如果根结点就是其中的一个结点，那么根结点一定是最近公共祖先结点。

2. 两个结点在根节点的左右两侧。
![二叉树的最近公共祖先](./imgs/二叉树的最近公共祖先_左右两侧.jpg)
如上图所示，我们可以看到如果两个结点分别分布在根节点的左右两侧，也就是说左子树和右子树上，那么他们的公共祖先结点一定只能是根结点。

3. 如果两个结点在根节点的左子树上。
![二叉树的最近公共祖先](./imgs/二叉树的最近公共祖先在左侧.jpg)<br>

如上图所示，如果两个结点都在根结点的左子树上，那么我们就可以缩小查找范围，只需要查找左子树即可，从左子树上开始查找。在左子树上查找可能又有两种情况：
* 一个在左侧一个在右侧，那么根结点就是他们的子节点。
* 都在同一侧，那么就继续缩小范围。
最终要么返回他们的根结点，要么返回他们中的某一个结点。
4. 如果两个结点在根节点的右子树上。
同理，如果两个结点都在右子树上，跟都在左子树上一样，也是缩小查找范围。

因此，我们最主要的问题就是，如何找到结点是否在某颗树上。实现代码如下：
```js
  // 查找结点是否在子树身上
  function find(root,node){
    if(root === null || root === node){
      return root;
    }
    let left = find(root.left,node);
    let right = find(root.right,node);
    return left ? left :right;
  }
```
接下来我们就可以按照我们的思路来实现了。
## 暴力破解法
```js
var lowestCommonAncestor = function(root, p, q) {

  // 如果根结点是其中的某一个结点，那么就直接返回。
  if (root === null || root === p || root === q) {
    return root;
  }
  let pInLeft = find(root.left,p) !== null;
  let pInRight = !pInLeft;
  let qInLeft = find(root.left,q) !== null;
  let qInRight = !qInLeft;
  // 都在左子树上，就继续递归遍历左子树
  if(pInLeft && qInLeft){
    return lowestCommonAncestor(root.left,p,q);
  }
  // 都在右子树上，就继续递归遍历右子树
  if(pInRight && qInRight){
    return lowestCommonAncestor(root.right,p,q);
  }
  //一个在左子树一个在右子树那么就肯定是根结点
  return root;
  // 查找结点是否在子树身上
  function find(root,node){
    if(root === null || root === node){
      return root;
    }
    let left = find(root.left,node);
    let right = find(root.right,node);
    return left ? left :right;
  }
};
```
如上代码所示：我们每次都查找p或者q是在哪个子树上。这样的话每个树都得找两遍。事实上，我们只需要知道pq是否同时在左子树或者同时在右子树上。再进一步我们可以这样想：如果它全在左子树上，那么肯定不在右子树上，因此在右子树查找一定返回null。同理，如果它全在右子树上，那么在左子树上查找一定返回null，这样的话就可以根据返回结果来确定应该去哪颗树上查找。代码如下图所示：
```js
var lowestCommonAncestor1 = function (root, p, q) {
  if (root === null || root === p || root === q) {
    return root;
  }

  let pqInLeft = find(root.left,p,q);
  let pqInRight = find(root.right,p,q);
  if(pqInLeft === null){
    // 说明在左子树上没有找到p和q，那么它肯定在右子树上。
    return lowestCommonAncestor(root.right,p,q);
  }
  if(pqInRight === null){
     // 说明在右子树上没有找到p和q，那么它肯定在左子树上。
    return lowestCommonAncestor(root.left,p,q);
  }
  return root;
  // 查找是否有结点是否在子树身上
  function find(root,nodep,nodeq){
    if(root === null || root === nodep || root === nodeq){
      return root;
    }
    let left = find(root.left, nodep, nodeq);
    let right = find(root.right, nodep,nodeq);
    return left ? left :right;
  }
};
```
通过上面的分析，我们虽然简化了代码，但是提交后还是发现执行用时比较长，这是因为还是做了很多无用的查找。
事实上我们再进一步研究发现`lowestCommonAncestor1`也是返回一个结点，它和我们查找的过程是相似的。如下所示：
![二叉树的最近公共祖先](./imgs/二叉树的最近公共祖先_合并代码.jpg)
我们可以看上部分代码，可以发现实际上`lowestCommonAncestor1`也是查找，如果不在左子树就去右子树上查找，而`find`的功能就是查找两个结点是否在左子树上，然后再根据查找的结果来判断`lowestCommonAncestor1`中的第一个参数应该是哪个子树，事实上这个功能lowestCommonAncestor1已经有了，因此我们可以直接递归调用它本身即可。如下所示：
```js
var lowestCommonAncestor = function (root, p, q) {
  if (root === null || root === p || root === q) {
    return root;
  }
  let pqInLeft = lowestCommonAncestor(root.left, p, q);  // p,q至少有一个存在左子树上。
  let pqInRight = lowestCommonAncestor(root.right, p, q); // p,q至少有一个存在右子树上。
  if(pqInLeft === null){
    // 说明在左子树上没有找到p和q，那么它肯定在右子树上。
    return pqInRight;
  }
  if(pqInRight === null){
     // 说明在右子树上没有找到p和q，那么它肯定在左子树上。
    return pqInLeft;
  }
  return root;
};
```
总而言之，二叉树的最近公共祖先就是不断地判断结点在哪颗树上，然后在这个树上找，如果找到一个就直接返回就行，说明它是最近的公共祖先结点，如果找到两个说明他们的祖先结点才是最近公共结点。







## 总结

### 查找一颗二叉树上是否有某个结点
递归时，先只考虑最简单的情形，就是一个根节点再加上两个左右子结点。
```js
  // 查找结点是否在子树身上
  function find(root,node){
    if(root === null|| root === node){
      return root;
    }
    let left = find(root.left,node);
    let right = find(root.right,node);
    return left ? left :right;
  }
```