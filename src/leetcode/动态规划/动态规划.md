# 动态规划
动态规划，指的是你当前的状态会受到你之前的状态的影响（或者说你现在的状态会影响到你将来的状态）。

## 动态规划的思考步骤：
1. 由于每一个状态都会受到之前的状态的影响，因此我们需要一个**状态容器**来保存所有的状态。 一般是一维或者二维数组。
2. 容器初始化，一般都会知道最初始的几个状态
3. 状态转移方程
4. 返回这个结果


### 爬楼梯问题
状态方程：f(k) = f(k-1) + f(k-2)
```js
var climbStairs = function (n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
  // 第一步：创建一个状态容器：
  var arr = [];
  // 第二步：初始化：
  arr[0] = 1;
  arr[1] = 2;
  // 状态转移方程，计算每一个状态
  for(let i = 2;i < n;i++){
      arr[i] = arr[i-1] + arr[i-2];
  }
  // 返回指定的状态
  return arr[n-1];
};
```

### 不同路径问题：
```js
var uniquePaths = function (m, n) {
  // 第一步：状态容器：
  var arr = new Array(m);
  for(let j = 0;j < arr.length;j++){
      arr[j] = new Array(n);
  }
  // 初始化
  arr[0][1] = 1;
  console.log(arr);
  for(let i =0;i < m;i++){
      arr[i][0] = 1;
  }
  for(let j =0;j < n;j++){
      arr[0][j] = 1;
  }
  // 状态转移方程:f(i,j) = f(i-1,j)+f(i,j-1)
  for(let i = 1;i < m;i++){
      for(let j = 1;j < n;j++){
          arr[i][j] = arr[i-1][j] + arr[i][j-1];
      }
  }
  return arr[m-1][n-1];
};

```


### 动态规划状态转移方程的确认
动态规划问题，最难的就是状态转移方程的确认
1. 确定状态。也就是原问题和子问题中变化的变量。

## 零钱兑换

```js
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

面对这种题目，我们的第一想法使用暴力法就是**穷举法**。但是很明显，硬币的数量不确定，而且每种硬币的使用次数不限制，也就是说我们穷举时，可能会有无数的次数。然后我们需要从这无数次中找出符合条件的，我们很难从这无数种可能种进行处理，因此，像这种处理起来数据比较庞大，很难穷举的基本上就需要使用**动态规划了**。动态规划最重要的就是找到**状态转移方程**。

#### 状态转移方程

状态转移方程，指的是某种状态依赖于其他的状态，或者说由其他状态得到而来。因此，**最重要的就是找到哪个在发生变化，也就是我们常说的`dp[i]`。这里的i到底是什么。**

一般有两种方法，自顶向下或者自底向上。因此，我们最好的办法就是去查找这个自顶向下和自底像上中变化的是哪个。以上面中题目为例，一共有两个变量。不同面额的硬币和总金额，那么转移的基本上就是硬币或者总金额。我们分析可以发现，每种硬币的数量是无限的，也就是说使用一次之后还可以重复使用。这样的话就不涉及变化了。因此，变化的应该是总金额。如下所示：

![](./imgs/动态规划之凑零钱问题.png)

如上图所示：我们可以发现总金额为6的硬币个数可以等于：

1. 拿一枚面值为 1 的硬币 + 总金额为 5 的最优解法的硬币数量。相当于db(5)+1。这里的1是指拿金额为1的这一枚硬币。
2. 拿一枚面值为 2 的硬币 + 总金额为4 的最优解法的硬币数量。相当于db(4)+1。这里的1是指拿金额为2的这一枚硬币。
3. 拿一枚面值为 4 的硬币 + 总金额为1的最优解法的硬币数量。相当于db(1)+4。这里的1是指拿金额为2的这一枚硬币。
以上三种情况的最小值。
也就是说db[6] = Math.min(db(5)+1,db(4)+1,db(2)+1)。这里的5,4,2分别代表amount-coin。也就是说：
```js
db[i] = Math.min(db[i-coin1]+1,db[i-coin2]+1,db[i-coin3]+1,...);
```
这就是我们得到的状态转移方程。

#### 初始化容器
由于动态规划问题，一般都会有很多重复的计算，因此，通常会使用一个容器来存储这些状态。因此，我们需要直到我们要初始化一个什么样的容器。一般需要考虑这些：
1. 是一维数组，还是二维数组还是三维数组。一般是根据有几种状态来确定是几维数组。比如我们这里只有一种状态，那么就是一维数组。
2. 容器中状态是否需要初始化值（比如初始化为null或者初始化为Infinity）


#### 确定初始化值
对于动态规划问题来说，一般都能够很直接的得到初始化的一个或者几个值。比如我们这里的硬币问题，db[0]=0。

#### 代码实现
```js
var coinChange = function (coins, amount) {
    // 初始化状态容器
    let dp = new Array(amount + 1).fill(Infinity); 
    // 初始化状态
    dp[0] = 0;
    // 状态转移方程
    for (let i = 1; i <= amount; i++) {
        for (let coin of coins) {
            if (i - coin >= 0) {
                // 实现状态转移方程
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    // 如果不存在就是-1。如果存在就直接返回
    return dp[amount] === Infinity ? -1 : dp[amount];
};


```