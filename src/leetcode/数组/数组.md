# 数组


## 56. 合并区间
>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].


### 分析
合并多个区间，最关键的是判断前后两个区间是否有交集，如果有交集就找出两个区间的最小值和最大值，就是他们合并后的区间，如果没有交集，他们两个就是不重叠的区间。因此，**关键是如何找出两个数组中的元素有没有交集。**
![数组区间](./imgs/数组区间.png)
如上图所示，我们可以发现
1. 如果两个区间之间有重合，那么前一个区间的第二个数应该大于第二个区间的第一个数。比如[1,3]和[2,6]两个区间，第一个区间的第二个值是3，第二个区间的第一个值是2，3>2因此，[1,3]和[2,6]是有重合的，他们可以进行区间合并。
2. 如果两个区间不重合，那么第一个区间的第二个值小于第二个区间的第一个值，比如[8,10]和[15,18]他们之间就是不重合的。

但是由于数组本身是无序的，它可能会出现[1,6],[8,10],[15,18]，这种突然又出现小的比较小的值，比如[2,9]，这样的话就会出现[2,9]需要和前面所有的进行比较，肯定是比较麻烦的。因此我们最好在一开始就按照区间的左侧的值进行排序，变成：[1,6],[2,9],[8,10],[15,18]这种有序的。然后再判断是否有重合。因此，我们最终的实现思路是：
1. 排序。按照区间的第一个数字进行排序。
2. 根据前后两个区间的第二个值和第一个值进行比较。判断重合。如果重合取最值，如果不重合就保存起来。
最终的代码实现如下：
```js
    var merge = function (intervals) {
        intervals.sort((a, b) => a[0] - b[0]); // [[2, 6], [1,9],[11, 13], [15, 18]]
        let results = [intervals[0]];
        for (let i = 1; i < intervals.length; i++) {
            let item = results[results.length - 1];
            if (intervals[i][0] > item[1]) {
                results.push(intervals[i]); // 这两个是不连续的
            } else {
                let min = Math.min(...item, ...intervals[i]);
                let max = Math.max(...item, ...intervals[i]);
                results[results.length - 1] = [min, max];
            }
        }
        return results;
    };
```

 